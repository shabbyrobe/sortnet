package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"

	"github.com/shabbyrobe/sortnet"
	"golang.org/x/tools/imports"
)

const Usage = `sortnetgen: generates a sorting network of specific sizes

Usage: sortnetgen [options] <input>...

Each <input> contains an optional reverse direction specifier, a fully qualified
type name and a 'sizespec', in a fairly loose interpretation of the below grammar:
 
	<input>     = <dir>? <fqtype> ':' <sizespec>
	<dir>       = '+'? '-'? 
	<fqtype>    = ( <pkg> '.' ) <type>
	<sizefix>   = [0-9]+
	<sizerange> = [0-9]+ '-' [0-9]+
	<size>      = <sizefix> | <sizerange>
	<sizespec>  = <size> (, <size>)+

Generate forward and reverse sorting network of sizes 3-5 for example.com/yep.Foo
    +-example.com/yep.Foo:3-5

Generate forward sorting network of sizes 3-5 for example.com/yep.Foo
    example.com/yep.Foo:3-5

Generate reverse sorting network of sizes 3, 4, 5 and 9 for string:
    -string:3-5,9

The type will be the basis for the comparison. If <input> is a builtin primitive, '<' is
used for comparisons, otherwise -castpl is used to determine how to compare and swap.

If the type contains a package, it is imported. It is not validated.

If the leading direction specifier is not present, '+' is inferred, otherwise if '+' is
found, a forward sort method is generated and if '-' is found, a reverse sort method is
generated.
`

type usageError string

func (u usageError) Error() string { return string(u) }

func IsUsageError(err error) bool {
	_, ok := err.(usageError)
	return ok
}

type Command struct {
	pkg             string
	prefix          string
	format          bool
	lessTemplate    string
	greaterTemplate string
	out             string
	array           bool
	slice           bool
	wrap            bool
}

func (cmd *Command) Flags(flags *flag.FlagSet) {
	flags.StringVar(&cmd.pkg, "pkg", os.Getenv("GOPACKAGE"), "package name")
	flags.StringVar(&cmd.out, "out", "sortnet_gen.go", "output file name")
	flags.BoolVar(&cmd.format, "format", true, "run gofmt on result")
	flags.BoolVar(&cmd.array, "array", false, "Generate fixed-length array sorters")
	flags.BoolVar(&cmd.slice, "slice", true, "Generate slice sorters")
	flags.BoolVar(&cmd.wrap, "wrap", true, "Generate wrapper sorter that chooses the right sort based on len(a) and returns false if none present")
	flags.StringVar(&cmd.greaterTemplate, "greater", "", ""+
		"'compare-and-swap' template that evaluates to true if the first value is greater "+
		"than the second. Used if the sort values are structs. "+
		"Note: this may be passed multiple times and interleaved with <input>; "+
		"each subsequent -less applies to the inputs to its right")
	flags.StringVar(&cmd.lessTemplate, "less", "", ""+
		"Like -greater, except used for reverse sorting")
}

func (cmd *Command) Synopsis() string { return "Generate enum-ish helpers from a bag of constants" }

func (cmd *Command) Usage() string { return Usage }

func (cmd *Command) Run(args ...string) (err error) {
	if cmd.out == "" {
		return usageError("-out not set")
	}
	if cmd.pkg == "" {
		return usageError("-pkg not set")
	}

	var lessTemplate, greaterTemplate *template.Template
	if cmd.greaterTemplate != "" {
		greaterTemplate, err = template.New("").Parse(cmd.greaterTemplate)
		if err != nil {
			return err
		}
	}

	if cmd.lessTemplate != "" {
		lessTemplate, err = template.New("").Parse(cmd.lessTemplate)
		if err != nil {
			return err
		}
	}

	var inputs = make([]Input, 0, len(args))
	var idx = 0

	// FIXME: we can use a flagset to keep parsing args after each input instead
	// of the terrible hacks below, which can also help with --array and --slice
	for i := 0; i < len(args); i++ {
		arg := args[i]

		arg, i, err = eatTemplate(lessTemplate, "less", args, i)
		if err != nil {
			return err
		}

		arg, i, err = eatTemplate(greaterTemplate, "greater", args, i)
		if err != nil {
			return err
		}

		input, err := ParseInput(arg, idx)
		if err != nil {
			return err
		}
		input.LessTemplate = lessTemplate
		input.GreaterTemplate = greaterTemplate
		if err := input.ensureTemplates(); err != nil {
			return err
		}
		inputs = append(inputs, input)
		idx++
	}

	var buf bytes.Buffer

	{ // File init
		const preamble = "// Code generated by 'github.com/shabbyrobe/go-enumgen'. DO NOT EDIT."
		buf.WriteString(preamble)
		buf.WriteString("\n\n")
		buf.WriteString(fmt.Sprintf("package %s\n\n", cmd.pkg))

		for _, input := range inputs {
			if input.Package != "" {
				buf.WriteString(fmt.Sprintf("import %q\n", input.Package))
			}
		}
	}

	var genBuf bytes.Buffer
	var wrappers = map[WrapperKey]*WrapperGen{}

	{ // Individual networks
		var gens []Gen
		for inputIndex, input := range inputs {
			for _, sz := range input.Sizes {
				net := sortnet.New(sz)
				gen := Gen{
					Input:    input,
					Exported: input.IsExported(),
					Network:  net,
					Slice:    cmd.slice,
					Array:    cmd.array,
				}

				fwds := []bool{}
				if input.Forward {
					fwds = append(fwds, true)
				}
				if input.Reverse {
					fwds = append(fwds, false)
				}

				for _, fwd := range fwds {
					gen.Forwards = fwd
					gens = append(gens, gen)
					if wg := wrappers[WrapperKey{inputIndex, fwd}]; wg == nil {
						wrappers[WrapperKey{inputIndex, fwd}] = &WrapperGen{
							Input:    input,
							Forwards: fwd,
							Methods:  map[int]string{},

							// FIXME: move into input to allow accumulation of flags
							Wrap: cmd.wrap,
						}
					}
					wrappers[WrapperKey{inputIndex, fwd}].Methods[sz] = gen.SliceName()
				}
			}
		}

		for _, gen := range gens {
			if err := genTpl.Execute(&genBuf, gen); err != nil {
				return err
			}
		}
	}

	{ // Wrappers
		for _, wrapper := range wrappers {
			if err := wrapperTpl.Execute(&buf, wrapper); err != nil {
				return err
			}
		}
	}

	// Wrappers should go above individual functions:
	buf.Write(genBuf.Bytes())

	var out = buf.Bytes()

	{ // Gofmt
		if cmd.format {
			var err error
			out, err = imports.Process(cmd.out, out, nil)
			if err != nil {
				return err
			}
		}
	}

	{ // Write output
		var write bool
		existing, err := ioutil.ReadFile(cmd.out)
		if os.IsNotExist(err) || err == nil {
			write = true
		} else if err != nil {
			return err
		} else if !bytes.Equal(out, existing) {
			write = true
		}

		if write {
			return ioutil.WriteFile(cmd.out, out, 0644)
		}
	}

	return nil
}

func eatTemplate(into *template.Template, name string, args []string, idx int) (arg string, next int, err error) {
	next = idx
	arg = args[next]

	var tplStr string
	if arg == "-"+name || arg == "--"+name {
		next++
		if next >= len(args) {
			err = fmt.Errorf("-%s missing value", name)
			return
		}
		tplStr = args[next]

	} else if strings.HasPrefix(arg, "-"+name+"=") || strings.HasPrefix(arg, "--"+name+"=") {
		parts := strings.SplitN(arg, "=", 2)
		tplStr = parts[1]

	} else {
		return arg, next, nil
	}

	tpl, err := template.New("").Parse(tplStr)
	if err != nil {
		return arg, next, err
	}
	*into = *tpl
	return arg, next, nil
}
